/*******************************************************************************
 * Copyright 2010 - 2011, Qualcomm Innovation Center, Inc.
 *
 *    Licensed under the Apache License, Version 2.0 (the "License");
 *    you may not use this file except in compliance with the License.
 *    You may obtain a copy of the License at
 *
 *        http://www.apache.org/licenses/LICENSE-2.0
 *
 *    Unless required by applicable law or agreed to in writing, software
 *    distributed under the License is distributed on an "AS IS" BASIS,
 *    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *    See the License for the specific language governing permissions and
 *    limitations under the License.
 ******************************************************************************/

import java.util.ArrayList;
import java.util.HashMap;
import java.util.Random;

class GenerateRunnableCode {
	
    protected static int defaultArrayLen = 3;
	
    /*
     * have one for each type?
     * currently there's one defaultString and everything else is defaultValue
     * (i.e. 0)
     */
    protected static String defaultString[] = {"\"one\"", "\"two\"", 
                                               "\"three\"", "\"four\"", "\"five\"", "\"six\"", "\"seven\"", 
                                               "\"eight\"", "\"nine\"", "\"ten\""};
    protected static String defaultValue = "0";
    protected static String[] defaultObjectPath = {"\"/one\"", "\"/two\"", 
                                                   "\"/three\"", "\"/four\"", "\"/five\"", "\"/six\"", "\"/seven\"", 
                                                   "\"/eight\"", "\"/nine\"", "\"/ten\""}; 
    protected static String[] defaultSignature = {"\"b\"", "\"d\"", "\"g\"", 
                                                  "\"i\"", "\"n\"", "\"o\"", "\"q\"", "\"s\"", "\"t\"", "\"u\"", "\"v\"", 
                                                  "\"x\"", "\"y\""};

    public static int counterIndex = -1;
    public static final char[] counters = {'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p'};

    public static HashMap<String, Boolean> argNames = new HashMap<String, Boolean>();
    
    protected static String generateClientMethodCalls(ArrayList<MethodDef> methodList,
                                                      String objName) {
        String output = "";
        String code;
        MethodDef tempMeth;
        ArgDef tempArg;
        for(int i = 0; i < methodList.size(); i++){
            tempMeth = methodList.get(i);
            code = String.format("printf(\"Making %s method call....\\n\");", 
                                 tempMeth.getName()); 
            output += FormatCode.indentln(code, 1);
            output +=
                GenerateRunnableCode.generateRunnableArgs(tempMeth.argList,
                                                          true,
                                                          tempMeth.getName());
            output += WriteCode.indentDepth 
                + objName + "."
                + tempMeth.getName() 
                + "(";
			
            //print out all the argument names that is passed to the method call
            for(int j = 0; j < tempMeth.argList.size(); j++){
                tempArg = tempMeth.argList.get(j);
                output += tempMeth.getName() 
                    + tempArg.getArgName()
                    + appendArgType(tempArg.getArgType());
                if(tempArg.argType.charAt(0) == 'a' && tempArg.argType.charAt(1) != 'a'){
                    output += ", " 
                        + tempMeth.getName() 
                        + tempArg.getArgName()
                        + appendArgType(tempArg.getArgType())
                        + "NumElements";
                }
                if(j != tempMeth.argList.size()-1){
                    output += ", ";
                }
            }
            output += ");\n";
            output += GenerateRunnableCode.generatePrintfRunnable(
                tempMeth.argList,
                false,
                tempMeth.getInterfaceName() + "::" + tempMeth.getName(),
                tempMeth.getName(),
                false);
            output += "\n";
        }
		
        return output;
    }
	
    protected static String generateMethodHandler(MethodDef method){
        String output = "";

        String commentStr = "Below is the code generated by the -R flag.";
        output += FormatCode.blockComment(commentStr, 1);
		
        output += FormatCode.indent(1);
        output += "printf(\"Handling " 
            + method.getName() 
            + " method call...\\n\");\n";
        output += generateRunnableArgs(method.argList, false, method.getName());
        output += generatePrintfRunnable(method.argList, 
                                         true, 
                                         method.getInterfaceName() + "::" + method.getName(), 
                                         "",
                                         false);
		
        return output;
    }
	
    protected static String generateSignalHandler(SignalDef signal){
        String output = "";

        String commentStr = "Below is the code generated by the -R flag.";
        output += FormatCode.blockComment(commentStr, 1);
        String code = String.format(
            "printf(\"Received %s signal...\\n\");",
            signal.getName());
        output +=  FormatCode.indentln(code, 1);		
        output += GenerateRunnableCode.generatePrintfRunnable(signal.argList, 
                                                              true, 
                                                              signal.getInterfaceName() + "::" + signal.getName(), 
                                                              "",
                                                              true);
        return output;
    }
	
    /**
     * This is called to generate the code that calls the "SendSignal" methods
     * @param signalList
     * @return
     */
    protected static String generateSendSignals(ArrayList<SignalDef> signalList){
        String output = "";
        if(signalList.isEmpty()) {
            return output;
        }
        SignalDef tempSig;
        ArgDef tempArg;
        String commentStr;
        commentStr = "The following code is added to this method handler so the " +
            "runnable service sends all the signals.";
        output += FormatCode.comment(commentStr, 1);
        for(int i = 0; i < signalList.size(); i++){
            tempSig = signalList.get(i);
            output += WriteCode.indentDepth 
                + "printf(\"\\nSending " 
                + tempSig.getName() 
                + " signal...\\n\");\n";
            output += generateRunnableArgs(tempSig.argList,
                                           true,
                                           tempSig.getName());
            output += WriteCode.indentDepth 
                + "Send" 
                + tempSig.getName() 
                + "(";
			
            for(int j = 0; j < tempSig.argList.size(); j++){
                tempArg = tempSig.argList.get(j);
                output += tempSig.getName() 
                    + tempArg.getArgName()
                    + appendArgType(tempArg.getArgType());
                if(tempArg.argType.charAt(0) == 'a' && tempArg.argType.charAt(1) != 'a'){
                    output += ", " 
                        + tempSig.getName() 
                        + tempArg.getArgName() 
                        + appendArgType(tempArg.getArgType())
                        + "NumElements";
                }
                if(j != tempSig.argList.size()-1){
                    output += ", ";
                }
            }
			
            output += ");\n";
            output += generatePrintfRunnable(tempSig.argList, 
                                             false, 
                                             tempSig.getInterfaceName() + "::" + tempSig.getName(), 
                                             tempSig.getName(),
                                             true);
        }
		
        return output;
    }
    
    /**
     * Generate the client main code that does Set and Get for each property
     * @param properties
     * @return
     */
    protected static String generateClientProperties(
        ArrayList<PropertyDef> properties, String iface, String objName){
    	String output = "";
    	PropertyDef prop;
    	String inputPacking;
    	
    	for(int i = 0; i < properties.size(); i++){
            prop = properties.get(i);
            //create a temporary list that holds a single property.
            ArrayList<ArgDef> tempList = new ArrayList<ArgDef>();
            tempList.add(prop.getArg());
            //write the code for calling SetProperty
            if(!argNames.containsKey(prop.getName() + "SetVal")){
                output += String.format("%sMsgArg %sSetVal;\n",
                                    FormatCode.indent(1),
                                    prop.getName());
                argNames.put(prop.getName() + "SetVal", true);
            }
            output += generateRunnableArgs(tempList, true, "");
            output += WriteCode.generateSetMsgArg(prop.getName() + "SetVal", 
                                                  prop.getSignature(), 
                                                  prop.getName() + appendArgType(prop.getSignature()), 
                                                  1);
            //make the SetProperty call
            output += String.format(
                "%sstatus = (%s.proxyBusObj)->SetProperty(\"%s\", \"%s\", %sSetVal);\n",
                FormatCode.indent(1),
                objName,
                iface,
                prop.getName(),
                prop.getName());
            //print out the value that will be set
            output += WriteCode.indentDepth 
                + "printf(\"SetProperty: "
                + prop.getName() + "(" + prop.getAccess() + ")"
                + " = %s returned with status(%s)\\n\", "
                + prop.getName()
                + "SetVal.ToString().c_str(), QCC_StatusText(status));\n";
            //write the code for calling GetProperty
            if(!argNames.containsKey(prop.getName() + "GetVal")) {
                output += String.format("%sMsgArg %sGetVal;\n", 
                                    FormatCode.indent(1),
                                    prop.getName());
                 argNames.put(prop.getName() + "GetVal", true);
            }
            output += String.format(
                "%sstatus = (%s.proxyBusObj)->GetProperty(\"%s\", \"%s\", %sGetVal);\n",
                FormatCode.indent(1),
                objName,
                iface,
                prop.getName(),
                prop.getName());
            //print out the value from GetProperty
            output += WriteCode.indentDepth
                + "if(status == ER_OK){\n"
                + WriteCode.indentDepth + WriteCode.indentDepth
                + "printf(\"GetProperty: "
                + prop.getName() + "(" + prop.getAccess() + ")"
                + " = %s\\n\", "
                + prop.getName()
                + "GetVal.v_variant.val->ToString().c_str());\n"
                + WriteCode.indentDepth
                + "}else{\n"
                + WriteCode.indentDepth + WriteCode.indentDepth
                + "printf(\"GetProperty: "
                + prop.getName() + "(" + prop.getAccess() + ")"
                + " failed with status(%s)\\n\", QCC_StatusText(status));\n"
                + WriteCode.indentDepth + "}\n";
			
            output += "\n";
    	}
    	
    	return output;
    }
	
    /**
     * 
     * @param argList list of args
     * @param isClient if this call was made by a client
     * @return string containing code for instantiating/initializing args
     */
    protected static String generateRunnableArgs(ArrayList<ArgDef> argList,
                                                 boolean isClient,
                                                 String methName){
        String output = "";
        ArgDef arg;
        for(int i = 0; i < argList.size(); i++){
            arg = argList.get(i);
            if(isClient){
                if(!argNames.containsKey(methName + arg.getArgName() + appendArgType(arg.getArgType()))) {
                    if(!WriteCode.isArgContainerType(arg)){
                        output += generateRunnableArgClientBasicType(arg, methName + arg.getArgName() + appendArgType(arg.getArgType()));
                    } else {
                        output += generateRunnableArgClientContainerType(arg, methName + arg.getArgName() + appendArgType(arg.getArgType()));
                        argNames.put(methName + arg.getArgName() + appendArgType(arg.getArgType()) + "NumElements", true);
                    } 
                    argNames.put(methName + arg.getArgName() + appendArgType(arg.getArgType()), true);
                }
            }else{ //generate code for service
           	if(!WriteCode.isArgContainerType(arg)){
                    output += generateRunnableArgServiceBasicType(arg, arg.getArgName());
            	} else {
                    output += generateRunnableArgServiceContainerType(arg, arg.getArgName());
            	}
            }
        }
        return output;
    }
    /**
     * This will take the list of arguments and produce a print statment that
     * will print the value of the items in the argList.  Handler code, is 
     * method handlers or signal handler. 
     * @param argList - the list of args the print statements will be used on
     * @param isHandlerCode - is the output in a method or signal handler.
     * @param methodName - name of the method, signal or property this print 
     *                     statment is associated with.
     * @param namePrefix - if the name has a prefix to the name found in the
     *                     ArgDef then it must be passed in.
     * @param isSignal - is the item to be printed a signal.
     * @return
     */
    protected static String generatePrintfRunnable(ArrayList<ArgDef> argList,
                                                   boolean isHandlerCode,
                                                   String methodName, 
                                                   String namePrefix,
                                                   boolean isSignal){
    	String output = "";
    	ArgDef arg;

        if(argList.isEmpty())
        {
            String code = "";
            if(isHandlerCode){
                if(isSignal){
                    code = String.format("printf(\"\\tReceived %s \\\"null\\\": null\\n\");", methodName);
                }
                else{
                    code = String.format("printf(\"\\tReturning %s \\\"null\\\": null\\n\");", methodName);
                }    
            }
            else{
                if(isSignal){
                    code = String.format("printf(\"\\tSent %s \\\"null\\\": null\\n\");", methodName);
                }
                else{
                    code = String.format("printf(\"\\tReturned %s \\\"null\\\": null\\n\");", methodName);
                }
            }
            output += FormatCode.indentln(code, 1);
        } 

    	for(int i = 0; i < argList.size(); i++){
            arg = argList.get(i);
            if (isHandlerCode){
                if(WriteCode.isArgContainerType(arg)){
                    output += generatePrintfRunnableHandlerContainerType(
                        arg, methodName, namePrefix + arg.getArgName());
                } else {
                    output += generatePrintfRunnableHandlerBasicType(
                        arg, methodName, namePrefix + arg.getArgName());
                }
            }else {
                if(WriteCode.isArgContainerType(arg)){
                    output += generatePrintfRunnableCallerContainerType(
                        arg, methodName, namePrefix + arg.getArgName() + appendArgType(arg.getArgType()));
                } else {
                    output += generatePrintfRunnableCallerBasicType(
                        arg, methodName, namePrefix + arg.getArgName() + appendArgType(arg.getArgType()));
                }

            }
    	}
    	return output;
    }
    
    /**
     * Take a single ArgDef with a signature that only contains basic data types 
     * and generate code that generates a variable of the type and initializes 
     * the variable.
     * @param arg a ArgDef argument that contains an element with a BasicType
     * @param varName the name of the varible
     * @return
     */
    protected static String generateRunnableArgClientBasicType(ArgDef arg, String varName ){
    	String output = "";
    	
    	String type;
    	type = arg.getArgType();
        char c = type.charAt(0);
    	if(arg.getArgDirection().equals("in")){
            output += String.format("%s%s %s = %s;\n", 
                                    FormatCode.indent(1),
                                    WriteCode.mapType(c),
                                    varName,
                                    getDefault(c));
    	} else {
            //a value will be assigned to this variable when making a method call.
            output += String.format("%s%s %s;\n", 
                                    FormatCode.indent(1),
                                    WriteCode.mapType(c),
                                    varName);
    	}
    	return output;
    }
    
    /**
     * Take a single ArgDef with a signature that only contains a container data type 
     * and generate code that generates a variable of the type and initializes 
     * the variable.
     * 
     * @param arg a ArgDef argument that contains an element with a BasicType
     * @param name the name of the varible
     * @return
     */
    protected static String generateRunnableArgClientContainerType(ArgDef arg, String name){
    	String output = "";
    	String code;
    	char c = arg.getArgType().charAt(0);
    	switch(c){
    	case '(':
            code = arg.getArgName() + "Struct " + name + ";";
            output += FormatCode.indentln(code, 1);
            if(arg.getArgDirection().equals("in")){
                output += generateRunnableArgStructContainerType(name, 
                                                                 arg.getArgType(),  
                                                                 arg.getArgName() + "Struct", 
                                                                 2);
            }
            break;
    	case 'a': {
    	    if(arg.getArgType().charAt(1) == '{'){
    	    	code = String.format("size_t %sNumElements;", name);
    	    	output += FormatCode.indentln(code, 1);
    	    	code = String.format("%sDictEntry *%s;", 
                                     arg.getArgName(),
                                     name);
    	    	output += FormatCode.indentln(code, 1);
    	    	if(arg.getArgDirection().equals("in")){
                    output += generateRunnableArgDictContainerType(
                        name, 
                        arg.getArgType(),  
                        arg.getArgName() + "DictEntry",
                        0,
                        2);
    	    	}
    	    }else if(arg.getArgType().charAt(1) == 'a'){
    	    }else if(arg.getArgType().charAt(1) == '('){
    	    	if(arg.getArgDirection().equals("in")){
                    code = String.format(
                        "%sStruct* %s = new %sStruct[%d];", 
                        arg.getArgName(),
                        name,
                        arg.getArgName(),
                        defaultArrayLen);
                    output += FormatCode.indentln(code, 1);
                    code = String.format(
                        "size_t %sNumElements = %d;",
                        name,
                        defaultArrayLen);
                    output += FormatCode.indentln(code, 1);
                    char counter = getCounterVar();
                    code = String.format(
                        "for(unsigned int " + counter + " = 0; " + counter + " < %sNumElements; " + counter + "++){",
                        name);
                    output += FormatCode.indentln(code, 1);
                    output += generateRunnableArgStructContainerType(name+"[" + counter + "]", 
                                                                     arg.getArgType().substring(1), 
                                                                     arg.getArgName() + "Struct",
                                                                     2);
                    output += FormatCode.indentln("}", 1);
                    endForLoop();
    	    	} else {
                    code = String.format(
                        "%sStruct* %s;", 
                        arg.getArgName(),
                        name);
                    output += FormatCode.indentln(code, 1);
                    code = String.format(
                        "size_t %sNumElements;",
                        name);
                    output += FormatCode.indentln(code, 1);
    	    	}
    	    }else{ //single dimensional array type
    	    	code = String.format("%s *%s;", 
                                     WriteCode.mapType(arg.getArgType().charAt(1)),
                                     name);
    	    	output += FormatCode.indentln(code, 1);
    	    	code = String.format("size_t %sNumElements;", name);
    	    	output += FormatCode.indentln(code, 1);
    	    	output += generateRunnableArgArrayContainerType(
                    name,   
                    arg.getArgType(),
                    WriteCode.mapType(arg.getArgType().charAt(1)),
                    2);
    	    }
    	    break;
    	}
    	case 'v' : {
    	}
    	default:
            break;
    	}
    	return output;
    }
    
    /**
     * this will produce code that assigns a default value to all varibles 
     * within a struct.
     * 
     * Note: This uses recursion to find the inner most element of nested structs.
     * 
     * @param varName the name used to access the varaible.
     * @param structSignature the full signature found inside a struct 
     *                        i.e. the struct signature without the outer parentheses.
     * @return
     */
    protected static String generateRunnableArgStructContainerType(String varName, String structSignature, String dataType, int indentDepth){
    	String output = "";
    	int structCount = 0;
    	int dictCount = 0;
    	int memberCount = 0;
    	for(int i = 1; i < structSignature.length()-1; i++){
            char c = structSignature.charAt(i);
            switch(c){
            case '(' : {
                String innerStructSig = WriteCode.innerStructSignature(structSignature.substring(i, structSignature.length()-1));
                output += generateRunnableArgStructContainerType(
                    varName + ".s" + structCount, 
                    innerStructSig,
                    dataType + "::s" + structCount + "Struct",
                    indentDepth);
                i += innerStructSig.length()-1;
                structCount++;
                break;
            }
            case ')':
                //Do nothing
                break;
            case 'a' :{
                if(structSignature.charAt(i+1) == '{'){
                    String innerSig = WriteCode.innerDictSignature(structSignature.substring(i));
                    output += generateRunnableArgDictContainerType(
                        varName+".d"+ dictCount,
                        innerSig,  
                        dataType +"::d"+ dictCount + "DictEntry",
                        0,
                        indentDepth);
                    i += innerSig.length() - 1;
                    dictCount++;
                }else if(structSignature.charAt(i+1) == '('){
                    String innerSig = WriteCode.innerStructSignature(structSignature.substring(i+1)); 
                    output += generateRunnableArgArrayContainerType(
                        varName+".s"+ structCount,
                        "a" + innerSig,
                        dataType + "::s" + structCount + "Struct",
                        indentDepth);
                    i += innerSig.length() - 1;
                    structCount++;
                }else{
                    output += generateRunnableArgArrayContainerType(
                        varName + ".member" + memberCount,
                        "a" + structSignature.charAt(i+1),
                        WriteCode.mapType(structSignature.charAt(i+1)),
                        indentDepth);
                    i++;
                    memberCount++;
                }
                break;
            }	
            default:
                output += FormatCode.indent(indentDepth) 
                    + varName 
                    + ".member" 
                    + memberCount 
                    + " = " 
                    + getDefault(structSignature.charAt(i)) 
                    + ";\n"; 
                memberCount++;
            }
    		
    	}
    	return output;
    }
    
    protected static String generateRunnableArgDictContainerType(String varName, String signature, String dataType, int loopDepth, int indentDepth){
    	String output = "";
    	String code;
    	code = String.format("%sNumElements = %d;",
                             varName,
                             defaultArrayLen);
    	output += FormatCode.indentln(code, indentDepth);
    	code = String.format("%s = new %s[%sNumElements];",
                             varName,
                             dataType,
                             varName);
    	output += FormatCode.indentln(code, indentDepth);
    	code = String.format("for(unsigned int i%1$d = 0; i%1$d < %2$sNumElements; i%1$d++){",
                             loopDepth,
                             varName);
    	output += FormatCode.indentln(code, indentDepth);
    	code = String.format("%s[i%d].key = %s;", 
                             varName,
                             loopDepth,
                             getDefault(signature.charAt(2)));
    	output += FormatCode.indentln(code, indentDepth+1);
    	switch(signature.charAt(3)){
        case '(':{
            String innerStruct = WriteCode.innerStructSignature(signature.substring(3));
            output += generateRunnableArgStructContainerType(
                varName + "[i" + loopDepth + "].value", 
                innerStruct, 
                dataType + "::valueStruct", 
                indentDepth+1);
            break;
        }
        case 'a':{
            if(signature.charAt(4) == '('){
                code = String.format("%s[i%d].valueNumElements = %d;", 
                                     varName,
                                     loopDepth,
                                     defaultArrayLen);
                output += FormatCode.indentln(code, indentDepth + 1);
                code = String.format("%s[i%d].value = new %s::valueStruct[%s[i%d].valueNumElements];", 
                                     varName,
                                     loopDepth,
                                     dataType,
                                     varName,
                                     loopDepth);
                output += FormatCode.indentln(code, indentDepth + 1);
                code = String.format("for(unsigned int i%d = 0; i%d < %s[i%d].valueNumElements; i%d++){",
                                     loopDepth + 1,
                                     loopDepth + 1,
                                     varName,
                                     loopDepth,
                                     loopDepth +1);
                output += FormatCode.indentln(code, indentDepth + 1);
                String innerStruct = WriteCode.innerStructSignature(signature.substring(4));
                output += generateRunnableArgStructContainerType(
                    varName + "[i" + loopDepth + "].value[i" + (loopDepth+1) + "]", 
                    innerStruct, 
                    dataType + "::valueStruct", 
                    indentDepth+2);
                output += FormatCode.indentln("}", indentDepth + 1);	
            }else if(signature.charAt(4) == '{'){
                String innerDict = WriteCode.innerDictSignature(signature.substring(3));
                output += generateRunnableArgDictContainerType(
                    varName + "[i" + loopDepth + "].value",
                    innerDict,
                    dataType + "::valueDictEntry",
                    loopDepth + 1,
                    indentDepth + 1);	
            }else{
                output += generateRunnableArgArrayContainerType(
                    varName + "[i" + loopDepth + "].value",
                    signature.substring(3, 5),
                    WriteCode.mapType(signature.charAt(4)), 
                    indentDepth+1);
            }
    			
            break;
        }
        default:{
            code = String.format("%s[i%d].value = %s;", 
                                 varName,
                                 loopDepth,
                                 getDefault(signature.charAt(3)));
            output += FormatCode.indentln(code, indentDepth+1);
        }		
    	}
    	output += FormatCode.indentln("}", indentDepth);
    	return output;
    }
    
    protected static String generateRunnableArgArrayContainerType(String varName,
                                                                  String signature,
                                                                  String dataType, 
                                                                  int indentDepth){
    	String output = "";
    	String code;
    	code = String.format("%sNumElements = %d;",
                             varName,
                             defaultArrayLen);
    	output += FormatCode.indentln(code, indentDepth);
    	code = String.format("%s = new %s[%sNumElements];",
                             varName,
                             dataType,
                             varName);
    	output += FormatCode.indentln(code, indentDepth);
        char counter = getCounterVar();
    	code = String.format("for(unsigned int " + counter + " = 0; " + counter + " < %sNumElements; " + counter + "++){", 
                             varName);
    	output += FormatCode.indentln(code, indentDepth);
    	switch(signature.charAt(1)){
        case '{':
            code = String.format("%s[" + counter + "].key = %s;", 
                                 varName,
                                 getDefault(signature.charAt(2)));
            output += FormatCode.indentln(code, indentDepth+1);
            code = String.format("%s[" + counter + "].value = %s;", 
                                 varName,
                                 getDefault(signature.charAt(3)));
            output += FormatCode.indentln(code, indentDepth+1);
            break;
        case '(':{
            output += generateRunnableArgStructContainerType(varName+"[" + counter + "]",
                                                             signature.substring(1),
                                                             dataType,
                                                             indentDepth+1);
            break;
        }
        default:{
            code = String.format("%s[" + counter + "] = %s;", 
                                 varName,
                                 getDefault(signature.charAt(1)));
            output += FormatCode.indentln(code, indentDepth+1);
            break;
        }
    			
    	}

    	output += FormatCode.indentln("}", indentDepth);
        endForLoop();
    	return output;
    }
    
    /**
     * Take a single ArgDef with a signature that only contains a single basic data type 
     * and generate code for the AllJoyn Service. This generates a variable of the indicated 
     * type and initializes the variable.
     * 
     * @param arg a ArgDef argument that contains an element with a BasicType
     * @param name the name of the varible
     * @return
     */
    protected static String generateRunnableArgServiceBasicType(ArgDef arg, String name){
    	String output = "";
    	String type = arg.getArgType();
    	char c;
    	
    	if(arg.getArgDirection().equals("out")){
    	    c = type.charAt(0);
    	    output += WriteCode.indentDepth 
    	        + name 
    	        + " = " 
    	        + getDefault(c) 
    	        + ";\n";
    	}    		
    	return output;
    }
    
    /**
     * Take a single ArgDef with a signature that only contains a container data type 
     * and generate code for the AllJoyn Service.
     * 
     * @param arg a ArgDef argument that contains an element with a BasicType
     * @param name the name of the varible
     * @return
     */
    protected static String generateRunnableArgServiceContainerType(ArgDef arg, String name){
    	String output = "";
    	String code;
    	if(arg.getArgDirection().equals("out")){
            char c = arg.getArgType().charAt(0);
            switch(c){
            case '(':
                output += generateRunnableArgStructContainerType(name, 
                                                                 arg.getArgType(),
                                                                 arg.getArgName() + "Struct",
                                                                 1);
                break;
            case 'a': {
                if(arg.getArgType().charAt(1) == '{'){
                    output += generateRunnableArgDictContainerType(name, 
                                                                   arg.getArgType(), 
                                                                   name + "DictEntry",
                                                                   0,
                                                                   1);
                }else if(arg.getArgType().charAt(1) == 'a'){
                }else if(arg.getArgType().charAt(1) =='('){
                    code = String.format(
                        "%sStruct* %s;", 
                        arg.getArgName(),
                        name);
                    code = String.format(
                        "%s = new %sStruct[%d];",
                        name,
                        name,
                        defaultArrayLen);
                    output += FormatCode.indentln(code, 1);
                    code = String.format(
                        "%sNumElements = %d;",
                        name,
                        defaultArrayLen);
                    output += FormatCode.indentln(code, 1);
                    char counter = getCounterVar();
                    code = String.format(
                        "for(unsigned int " + counter + " = 0; " + counter + " < %sNumElements; " + counter + "++){",
                        name);
                    output += FormatCode.indentln(code, 1);
                    output += generateRunnableArgStructContainerType(name+"[" + counter + "]", 
                                                                     arg.getArgType().substring(1),
                                                                     arg.getArgName() + "Struct",
                                                                     2);
                    output += FormatCode.indentln("}", 1);
                    endForLoop();
                }else{
                    output += WriteCode.indentDepth 
    		        + name 
    		        + " = new " 
    		        + WriteCode.mapType(arg.getArgType().charAt(1)) 
    		        + "[" 
    		        + defaultArrayLen 
    		        + "];\n";
                    output += WriteCode.indentDepth 
    		        + name 
    		        + "NumElements = " 
    		        + defaultArrayLen 
    		        + ";\n";
                    char counter = getCounterVar();
                    output += WriteCode.indentDepth 
    		        + "for(unsigned int " + counter + " = 0; " + counter + " < " 
    		        + name 
    		        + "NumElements; " + counter + "++){\n";
                    output += WriteCode.indentDepth 
    		        + WriteCode.indentDepth 
    		        + name 
    		        + "[" + counter + "] = " 
    		        + getDefault(arg.getArgType().charAt(1)) 
    		        + ";\n";
                    output += WriteCode.indentDepth 
    		        + "}\n";
                    endForLoop();
                }
                break;
            }
            case 'v' : {
            }
            default:
                break;
            }
    	}
    	return output;
    }

    protected static String generatePrintfRunnableHandlerContainerType(ArgDef arg, String methodName, String varName)
    {
        String output = "";
        String code;

        if(arg.getArgDirection().equals("in")){
            code = String.format("printf(\"\\tReceived %s \\\"%s\\\": \");", methodName, arg.getArgName());
        }
        else {
            code = String.format("printf(\"\\tReturning %s \\\"%s\\\": \");", methodName, arg.getArgName());
        }
        output += FormatCode.indentln(code, 1);
        char c = arg.getArgType().charAt(0);
        switch(c){
        case '(':
            output += generatePrintfForStruct(varName, arg.getArgType());
            break;
        case 'a': {
            if(arg.getArgType().charAt(1) == '{'){
                output += generatePrintfForDictionary(varName, arg.getArgType(), varName + "NumElements");
            }
            else{
                output += generatePrintfForArray(varName, arg.getArgType(), varName + "NumElements");
            }
            break;
        }
        default:
            break;
        }
        code = String.format("printf(\"\\n\");");
        output += FormatCode.indentln(code, 1);

        return output;
    }

    protected static String generatePrintfForStruct(String varName, String structSignature)
    {
        String output = "";
        String code;
        int structCount = 0;
        int dictCount = 0;
        int memberCount = 0;

        code = String.format("printf(\"(\");");
        output += FormatCode.indentln(code, 1);
 
        for(int i = 1; i < structSignature.length() - 1; i++)
        {
            char c = structSignature.charAt(i);
            switch(c){
            case '(':{
                String innerStructSignature = WriteCode.innerStructSignature(structSignature.substring(i, structSignature.length()-1));
                output += generatePrintfForStruct(varName + ".s" + structCount, innerStructSignature);
                i += innerStructSignature.length() - 1;
                structCount++;
                break;
            }
            case ')':
                break;
            case 'a':{ 
                if(structSignature.charAt(i + 1) == '{'){
                    String innerDictSignature = structSignature.substring(i, structSignature.indexOf('}')+1);
                    String memberName = varName + ".d" + dictCount;
                    output += generatePrintfForDictionary(memberName, innerDictSignature, memberName + "NumElements");
                    i += innerDictSignature.length()-1;
                    dictCount++;
                }
                else{
                    String innerArraySignature = "";
                    String memberName = "";
                    String numElements = "";
                    int isMember = 0;
                    int isStruct = 0;
                    if(structSignature.charAt(i + 1) == '('){
                        innerArraySignature += structSignature.substring(i, structSignature.indexOf(')')+1);
                        memberName = varName + ".s" + structCount;
                        numElements = varName + ".s" + structCount + "NumElements";
                        isStruct = 1;
                    }
                    else{
                        innerArraySignature += structSignature.charAt(i);
                        innerArraySignature += structSignature.charAt(i+1);
                        memberName = varName + ".member" + memberCount;
                        numElements = varName + ".member" + memberCount + "NumElements";
                        isMember = 1;
                    } 
                    output += generatePrintfForArray(memberName, innerArraySignature, numElements);
                    i += innerArraySignature.length()-1;
                    memberCount += isMember;
                    structCount += isStruct;
                }
                break;
            }
            default:
                output += generatePrintfBasicType(varName + ".member" + memberCount, c);
                memberCount++;
                break; 
            }
            if(i != structSignature.length()-2){
                code = String.format("printf(\",\");");
                output += FormatCode.indentln(code, 1);
            }
        }

        code = String.format("printf(\")\");");
        output += FormatCode.indentln(code, 1);

        return output;
    }

    protected static String generatePrintfForDictionary(String varName, String varType, String varNameNumElements)
    {
        String output = "";
        String code;

        char counter = getCounterVar();
        output += WriteCode.indentDepth
            + "for(unsigned int " + counter + " = 0; " + counter + " < " + varNameNumElements + "; " + counter + "++){\n";
        output += WriteCode.indentDepth;
        code = String.format("printf(\"{\");");
        output += FormatCode.indentln(code, 1);
        output += WriteCode.indentDepth;
        char key = varType.charAt(varType.indexOf('{') + 1);
        //char value = varType.charAt(varType.indexOf('{') + 2);
        output += generatePrintfBasicType(varName + "[" + counter + "].key", key);
        output += WriteCode.indentDepth;
        code = String.format("printf(\",\");");
        output += FormatCode.indentln(code, 1);
        output += WriteCode.indentDepth
            + WriteCode.indentDepth;
        String value = varType.substring(varType.indexOf('{') + 2, varType.indexOf('}'));
        char valueType = value.charAt(0);
        switch(valueType){
        case '(':{
            output += generatePrintfForStruct(varName + "[" + counter + "].value", value);
            break;
        }
        case 'a':{
            if(value.charAt(1) == '{'){
                output += generatePrintfForDictionary(varName + "[" + counter + "].value", value, varName + "[" + counter + "].valueNumElements");
            }
            else{
                output += generatePrintfForArray(varName + "[" + counter + "].value", value, varName + "[" + counter + "].valueNumElements");
            }
            break;
        }
        default:
            output += generatePrintfBasicType(varName + "[" + counter + "].value", valueType);
            break;
        }
        output += WriteCode.indentDepth;
        code = String.format("printf(\"}\");");
        output += FormatCode.indentln(code, 1);
        output += WriteCode.indentDepth
            + "}\n";
        endForLoop();

        return output;
    }

    protected static String generatePrintfForArray(String varName, String varType, String varNameNumElements)
    {
        String output = "";
        String code;
 
        char counter = getCounterVar();
        output += WriteCode.indentDepth
            + "for(unsigned int " + counter + " = 0; " + counter + " < " + varNameNumElements + "; " + counter + "++){\n";
        output += WriteCode.indentDepth;
        code = String.format("printf(\"[\");");
        output += FormatCode.indentln(code, 1);
        output += WriteCode.indentDepth;
        char c = varType.charAt(1);
        switch(c){
        case '(':{ //STRUCTo
            String innerStructSignature = WriteCode.innerStructSignature(varType.substring(1, varType.length()));
            output += generatePrintfForStruct(varName + "[" + counter + "]", innerStructSignature);
            break;
        }
        case 'a':{
            // NOT SUPPORTED
            break;
        }
        default:
            output += generatePrintfBasicType(varName + "[" + counter + "]", c);
            break;
        }
        output += WriteCode.indentDepth;
        code = String.format("printf(\"]\");");
        output += FormatCode.indentln(code, 1);
        output += WriteCode.indentDepth
            + "}\n";
        endForLoop();
 
        return output;
    }
    
    /**
     * Generate a printf statement that will print the value of the Basic type 
     * that for Signal Handler code and Method Handler code.
     * @param arg
     * @param methodName - The name of the Method, Signal, or Property that 
     *                     called this printf statment is associated with. 
     * @param varName
     * @return
     */
    protected static String generatePrintfRunnableHandlerBasicType(ArgDef arg, String methodName, String varName){
        String output = "";
        String code;

        if(arg.getArgDirection().equals("in")){
            code = String.format("printf(\"\\tReceived %s \\\"%s\\\": \");", methodName, arg.getArgName());
        }
        else {
            code = String.format("printf(\"\\tReturning %s \\\"%s\\\": \");", methodName, arg.getArgName());
        }
        output += FormatCode.indentln(code, 1);
        output += generatePrintfBasicType(varName, arg.getArgType().charAt(0));

        code = String.format("printf(\"\\n\");");
        output += FormatCode.indentln(code, 1);

        return output; 
    }

    protected static String generatePrintfBasicType(String varName, char varType)
    {
        String output = "";
        String code;

        switch(varType){
        case 'b':{ //BOOLEAN
            code = String.format("printf(\"%%s\", (%s) ? \"true\" : \"false\");", varName);
            output += FormatCode.indentln(code, 1);
            break;
        }
        case 'y': //fall through BITE
        case 'n': //fall through INT_16
        case 'q': //fall through UINT_16
        case 'i': //fall through INT_32
        case 'u':{ //UINT_32
            code = String.format("printf(\"%%d\", %s);", varName);
            output += FormatCode.indentln(code, 1);
            break;
        }
        case 'x': //fall through INT_64
        case 't':{ //UINT_64
            code = String.format("printf(\"%%lld\", %s);", varName);
            output += FormatCode.indentln(code, 1);
            break;
        }
        case 'v': {//VARIANT
            break;
        }
        case 'd':{ //DOUBLE;
            code = String.format("printf(\"%%f\", %s);", varName);
            output += FormatCode.indentln(code, 1);
            break;
        }
        case 'o': //fall through OBJECT PATH
        case 'g': //fall through ALLJOYN SIGNATURE
        case 's':{ //STRING
            code = String.format("printf(\"%%s\", %s.c_str());", varName);
            output += FormatCode.indentln(code, 1);
            break;
        }
        default:
        }

        return output;
    }
    

    protected static String generatePrintfRunnableCallerContainerType(ArgDef arg, String methodName, String varName)
    {
        String output = "";
        String code;

        if(arg.getArgDirection().equals("in")){
            code = String.format("printf(\"\\tSent %s \\\"%s\\\": \");", methodName, arg.getArgName());
        }
        else {
            code = String.format("printf(\"\\tReturned %s \\\"%s\\\": \");", methodName, arg.getArgName());
        }
        output += FormatCode.indentln(code, 1);
        char c = arg.getArgType().charAt(0);
        switch(c){
        case '(':{
            output += generatePrintfForStruct(varName, arg.getArgType());
            break;
        }
        case 'a': {
            if(arg.getArgType().charAt(1) == '{'){
                output += generatePrintfForDictionary(varName, arg.getArgType(), varName + "NumElements");
            }
            else{
                output += generatePrintfForArray(varName, arg.getArgType(), varName + "NumElements");
            }
            break;
        }
        default:
            break;
        }
        code = String.format("printf(\"\\n\");");
        output += FormatCode.indentln(code, 1);

        return output;
    }

    
    /**
     * Generate a printf statement that will print the value of the Basic type 
     * that for runnable code.  For example the code found in the main() client
     * code. 
     * @param arg
     * @param methodName - the method, signal, or property the value is being
     *                     printed for
     * @param name
     * @return
     */
    protected static String generatePrintfRunnableCallerBasicType(ArgDef arg, String methodName, String varName){
        String output = "";
        String code;

        if(arg.getArgDirection().equals("in")){
            code = String.format("printf(\"\\tSent %s \\\"%s\\\": \");", methodName, arg.getArgName());
        }
        else {
            code = String.format("printf(\"\\tReturned %s \\\"%s\\\": \");", methodName, arg.getArgName());
        }
        output += FormatCode.indentln(code, 1);
        output += generatePrintfBasicType(varName, arg.getArgType().charAt(0));

        code = String.format("printf(\"\\n\");");
        output += FormatCode.indentln(code, 1);
        return output;
    }
  
    protected static char getCounterVar()
    {
        counterIndex++;
        return counters[counterIndex];
    }
    protected static void endForLoop()
    {
        counterIndex--;
    }
    

    /**
     * Creates a String containing the alljoyn code for initializing property
     * variables of basic types in the service class constructor.
     * 
     * @param propList - list of properties, could be empty
     * @param indentDepth - depth to which each line should be indented by
     * @return the String with the property variable initializations
     */
    protected static String generatePropertyInitialization(ArrayList<PropertyDef> propList, int indentDepth) {
        String output = "";
        String code = "";
        PropertyDef prop;
        ArgDef propArg;
        for(int i = 0; i < propList.size(); i++){
            prop = propList.get(i);
            propArg = prop.getArg();
            // Initialize Properties of Container Types
            if(WriteCode.isSignatureContainerType(prop.getSignature())) {
                /* 
                 * Create a temp ArgDef in the "out" direction so that
                 * generateRunnableArgServiceContainerType generates the 
                 * initialization code
                 */ 
                ArgDef tempArg = new ArgDef(propArg.getArgName(), 
                                            propArg.getArgType(),
                                            "out", 
                                            propArg.getVariantTypes());
                output += generateRunnableArgServiceContainerType(tempArg, prop.getName());
            }
            // Initialize Properties of Basic Types
            else {
                code = String.format("%s = %s;", prop.getName(), getDefault(prop.getSignature().charAt(0)));
                output += FormatCode.indentln(code, indentDepth);
            }
        }
        return output;
    }

    /**
     * This will assign a random value for the type specified by it signature
     * 
     * Strings are randomly picked from an array of default values.
     * 
     * @param input the char of the simple type signature
     * @return a random value of that type in a string
     */
    protected static String getDefault(char input){
    	String varDef;
    	Random rand = new Random();
    	switch(input){
    	case 'y':{ //BITE
            //random value 0 to 255
            varDef = Integer.toString(rand.nextInt(256));
            break;
    	}
            
    	case 'b':{ //BOOLEAN
            //randomly generate true or false
            if(rand.nextInt(2) == 0){
            	varDef = "false";
            } else {
            	varDef = "true";
            }
            break;
    	}
    	case 'n':{ //INT_16
            //random value -32,768 to 32,767
            varDef = Integer.toString(rand.nextInt(65536) - 32768);
            break;
    	}
    	case 'q':{ //UINT_16
            //random value 0 to 65,535
            varDef = Integer.toString(rand.nextInt(65536));
            break;
    	}
    	case 'i':{ //INT_32
            //random value -2,147,483,648 to 2,147,483,647
            varDef = Integer.toString(rand.nextInt());
            break;
    	}
    	case 'u':{ //UINT_32	
            //random value 0 to 2,147,483,647 
            //note: this does not cover full range of uint_32
            varDef = Integer.toString(Math.abs(rand.nextInt()));
            break;
    	}
    	case 'x':{ //INT_64
            //random value -9,223,372,036,854,775,808 to 9,223,372,036,854,775,807
            varDef = Long.toString(rand.nextLong())+"LL";
            break;
    	}
    	case 't':{ //UINT_64
            //random value 0 to 9,223,372,036,854,775,807
            //note: this does not cover full range of uint_64
            varDef = Long.toString(Math.abs(rand.nextLong()))+"ULL";
            break;
    	}
    	case 'v': //VARIANT
            varDef = defaultValue;
            break;
    	case 'd':{ //DOUBLE
            varDef = Double.toString(rand.nextDouble() * rand.nextInt());
            break;
    	}
    	case 'o': //OBJECT PATH
            varDef = defaultObjectPath[rand.nextInt(10)];
            break;
    	case 'g':// ALLJOYN SIGNATURE
            varDef = defaultSignature[rand.nextInt(13)];
            break;
    	case 's': //STRING
            varDef = defaultString[rand.nextInt(10)];
            break;
    	default:
            varDef = "";
    	}
    	return varDef;
    }

    private static String appendArgType(String type) {
        type = type.replace("(", "");
        type = type.replace(")", "");
        type = type.replace("{", "");
        type = type.replace("}", "");
        return "_" + type;
    }
} // class RunnableGenerator
